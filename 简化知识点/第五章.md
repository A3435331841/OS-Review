# 第5章 CPU调度 (CPU Scheduling)

## 1. 基本概念

CPU调度是操作系统中的核心功能，它决定了哪个进程在何时获得CPU资源。多道程序设计的主要目标是在任何时候都让CPU忙碌起来，最大化CPU的利用率。

### 1.1 调度的层次

操作系统的调度通常分为三个层次：

1. **高级调度(作业调度)** : 负责将外存上的作业调入内存，为其分配必要资源
2. **中级调度(交换调度)** : 负责将内存中暂时不用的信息转移到外存，以便腾出内存空间
3. **低级调度(进程调度)** : 决定就绪队列中的哪个进程获得CPU资源

三者的运行频率各不相同：

* 作业调度：运行频率低，几分钟一次
* 进程调度：运行频率高，几十毫秒一次
* 中级调度：运行频率介于二者之间

### 1.2 CPU-I/O区间周期

进程执行过程中会交替进行CPU计算和I/O等待，这形成了CPU区间和I/O区间的交替序列：

* **CPU区间** : 进程使用CPU执行计算的时间段
* **I/O区间** : 进程等待I/O操作完成的时间段

研究表明，大多数进程的CPU区间分布呈现为大量短CPU区间和少量长CPU区间的特点。

### 1.3 进程调度方式

进程调度有两种基本方式：

1. **非抢占式调度(Non-preemptive Scheduling)** :

* 一旦进程获得CPU，就一直运行直到完成或自愿放弃CPU（例如进入阻塞状态）
* 简单，系统开销小，但无法处理紧急任务

1. **抢占式调度(Preemptive Scheduling)** :

* 允许操作系统根据某种原则（如更高优先级进程到达）强制剥夺正在运行进程的CPU
* 抢占原则包括：优先权、时间片用完等

### 1.4 引起进程调度的原因

主要有四种情况可能触发进程调度：

1. 正在运行的进程结束
2. 进程从运行状态转到等待状态（如进行I/O操作）
3. 进程从等待状态转到就绪状态（如I/O操作完成）
4. 进程从运行状态转到就绪状态（如时间片用完）

其中1和4属于非抢占式调度，2和3属于抢占式调度。

### 1.5 分派程序(Dispatcher)

分派程序是实际执行上下文切换的部分，负责：

* 保存当前进程的上下文
* 将CPU控制权交给被选中的进程
* 切换到用户态
* 跳转到用户程序的适当位置

分派延迟(Dispatch Latency)是指从一个进程切换到另一个进程所需的时间，也被称为调度时间。

## 2. 调度准则

评价CPU调度算法的主要准则包括：

1. **CPU利用率** : 保持CPU尽可能忙碌
2. **吞吐量** : 单位时间内完成的进程数
3. **周转时间** : 从进程提交到完成的时间
4. **等待时间** : 进程在就绪队列中等待的总时间
5. **响应时间** : 从提交请求到首次响应的时间

通常希望最大化CPU利用率和吞吐量，最小化周转时间、等待时间和响应时间。

### 2.1 周转时间和带权周转时间

* **周转时间** = 作业完成时间 - 作业提交时间
* **带权周转时间** = 周转时间 / 实际运行时间

带权周转时间反映了作业在系统中的相对效率，值越接近1表示效率越高。

## 3. 调度算法

### 3.1 先来先服务调度(FCFS)

 **基本原理** ：按照进程请求CPU的顺序分配CPU，即先请求CPU的进程先获得服务。

 **特点** ：

* 实现简单，只需维护一个FIFO队列
* 非抢占式算法
* 有利于长作业，不利于短作业
* 可能导致护航效应(convoy effect)：短进程排在长进程后面，等待时间过长

 **例子** ：
假设三个进程P1、P2、P3的CPU需求时间分别为24、3、3个时间单位：

* 如果按P1、P2、P3顺序到达，平均等待时间为(0+24+27)/3 = 17
* 如果按P2、P3、P1顺序到达，平均等待时间为(0+3+6)/3 = 3

可见进程到达顺序对性能影响很大。

### 3.2 最短作业优先调度(SJF)

 **基本原理** ：选择执行时间最短的进程优先执行。

 **特点** ：

* 可以证明，当一批作业同时到达时，SJF可以获得最短的平均周转时间
* 分为抢占式和非抢占式两种实现
* 抢占式SJF也称为最短剩余时间优先(SRTF)调度
* 主要问题是难以准确预知进程的执行时间

 **例子** ：
假设四个作业A、B、C、D的到达时间为0、1、2、3，执行时间为8、4、9、5：

* 使用非抢占式SJF，执行顺序会是A开始，然后B、D、C
* 使用抢占式SJF(SRTF)，A开始执行，但1时刻B到达后A会被抢占，执行顺序变成B完成后D、A、C

### 3.3 时间片轮转调度(RR)

 **基本原理** ：每个进程分配一个时间片，时间片用完后进程被挂起并放到就绪队列末尾。

 **特点** ：

* 特别适合交互式系统
* 响应时间 ≈ n × q (n为就绪进程数，q为时间片长度)
* 时间片大小选择很重要：太大会退化为FCFS，太小会导致过多的上下文切换开销
* 通常时间片设为10-100ms，而上下文切换时间一般少于10μs

 **例子** ：
假设进程A、B、C的执行时间为10、6、3个时间单位：

* 若时间片为4：执行顺序为A(4)→B(4)→C(3)→A(4)→B(2)→A(2)，平均等待时间为(13+4+6)/3 = 7.67
* 若时间片为1：更频繁切换，响应更快但开销更大

### 3.4 优先级调度

 **基本原理** ：每个进程有一个优先级，CPU分配给优先级最高的进程。

 **特点** ：

* 优先级可分为静态优先级(创建时确定)和动态优先级(运行中调整)
* 优先级的确定可考虑：进程类型、资源需求、用户要求等
* 主要问题是可能导致低优先级进程饥饿(starvation)
* 解决饥饿问题的方法是老化(aging)，即随着等待时间增加逐渐提高进程的优先级

### 3.5 高响应比优先调度

 **基本原理** ：选择响应比最高的进程优先执行，其中响应比 = 1 + 等待时间/执行时间。

 **特点** ：

* 综合考虑了等待时间和执行时间
* 等待时间相同时，有利于短作业
* 执行时间相同时，有利于等待时间长的作业
* 克服了SJF可能产生的饥饿问题

### 3.6 多级队列调度

 **基本原理** ：将就绪队列分为多个独立的队列，每个队列有自己的调度算法。

 **特点** ：

* 进程根据其特性被永久分配到特定队列
* 队列之间通常有优先级关系，如前台交互式进程队列优先于后台批处理进程队列
* 每个队列可以使用不同的调度算法，如交互式队列使用RR，批处理队列使用FCFS

### 3.7 多级反馈队列调度

 **基本原理** ：在多级队列的基础上，允许进程在不同队列之间移动。

 **特点** ：

* 设置多个优先级不同的队列，优先级高的队列时间片小
* 新进程进入最高优先级队列，若一个时间片内未完成则降到下一队列
* 高优先级队列为空时才调度低优先级队列的进程
* 高优先级队列有新进程到达时会抢占低优先级队列正在执行的进程
* 综合了多种调度算法的优点，可以同时满足各类进程需求：
  * 交互型进程：在高优先级队列获得快速响应
  * 短批处理作业：在前几个队列完成，获得较短周转时间
  * 长批处理作业：逐级下降但不会饥饿

## 4. 实际系统中的调度

现代操作系统通常采用复合的调度策略：

1. **Linux** : CFS(完全公平调度器)，基于进程的执行时间比例进行调度
2. **Windows** : 多级反馈队列的变种，考虑进程优先级和执行历史
3. **Unix/类Unix系统** : 综合考虑优先级、时间片和交互性的调度策略

## 5. 调度算法的选择

不同场景下适合不同的调度算法：

1. **批处理系统** : 强调吞吐量和周转时间，适合FCFS、SJF和优先级调度
2. **交互式系统** : 强调响应时间，适合时间片轮转和多级反馈队列
3. **实时系统** : 强调满足截止时间，需要特殊的实时调度算法

## 小结

CPU调度是操作系统的核心功能，不同的调度算法各有优缺点：

* FCFS简单但对短作业不公平
* SJF理论上能获得最短平均周转时间，但难以预测执行时间
* RR提供良好的响应时间，适合交互系统
* 优先级调度灵活但可能导致饥饿
* 高响应比兼顾等待时间和执行时间
* 多级队列和多级反馈队列综合了多种算法的优点

在实际系统中，通常会根据应用场景和系统目标选择合适的调度算法或多种算法的组合。
