# 第6-7章 进程同步及实例课后习题

## 练习6.6
**题干**: Race conditions are possible in many computer systems. Consider a banking system that maintains an account balance with two functions: deposit(amount) and withdraw(amount). These two functions are passed the amount that is to be deposited or withdrawn from the bank account balance. Assume that a husband and wife share a bank account. Concurrently, the husband calls the withdraw() function, and the wife calls deposit(). Describe how a race condition is possible and what might be done to prevent the race condition from occurring.

（竞争条件在许多计算机系统中都可能发生。考虑一个银行系统，它维护账户余额并提供两个函数：存款(deposit(amount))和取款(withdraw(amount))。这两个函数接收要存入或取出的金额作为参数。假设一对夫妻共享一个银行账户。丈夫并发调用withdraw()函数，而妻子调用deposit()函数。描述可能发生的竞争条件，以及如何防止这种竞争条件的发生。）

**解析**:

竞争条件分析:
- 当丈夫和妻子同时操作共享账户时，可能会出现竞争条件。这是因为每个操作（存款或取款）都不是原子的，一般包括以下步骤：
  1. 读取当前账户余额
  2. 计算新的余额（加上或减去相应的金额）
  3. 将新余额写回账户

- 假设初始余额为1000元，丈夫要取500元，妻子要存500元，理想情况下最终余额应为1000元。但是如果操作不是原子的，可能会发生以下情况：
  1. 丈夫读取余额(1000元)
  2. 妻子读取余额(1000元)
  3. 丈夫计算新余额(1000-500=500元)
  4. 妻子计算新余额(1000+500=1500元)
  5. 丈夫写入新余额(500元)
  6. 妻子写入新余额(1500元)

最终余额变成了1500元，而不是预期的1000元。这就是竞争条件。

解决方案:
1. 使用互斥锁(mutex)：在操作账户余额之前获取锁，操作完成后释放锁，确保同一时刻只有一个进程能修改账户状态。
2. 使用信号量：与互斥锁类似，使用二进制信号量控制对共享资源的访问。
3. 使用管程(monitor)：将存款和取款操作封装在管程中，由管程保证这些操作的互斥执行。
4. 原子操作：将读取-修改-写入作为一个不可分割的原子操作来实现。

## 练习6.23
**题干**: Servers can be designed to limit the number of open connections. For example, a server may wish to have only N socket connections at any point in time. As soon as N connections are made, the server will not accept another incoming connection until an existing connection is released. Illustrate how semaphores can be used by a server to limit the number of concurrent connections.

（服务器可以设计为限制开放连接的数量。例如，服务器可能希望在任何时间点只有N个套接字连接。一旦建立了N个连接，服务器将不会接受另一个传入连接，直到释放现有连接。说明服务器如何使用信号量来限制并发连接的数量。）

**解析**:

使用信号量控制并发连接数的解决方案:

1. 初始化一个计数信号量，初值为N（允许的最大连接数）
```c
semaphore connections = N;
```

2. 在服务器接受新连接之前，执行P(wait)操作
```c
P(connections);  // 尝试获取一个连接资源
// 如果connections > 0，则connections减1并继续执行
// 如果connections = 0，则阻塞直到有连接被释放
accept_connection();  // 接受新连接
```

3. 当连接关闭时，执行V(signal)操作
```c
close_connection();  // 关闭连接
V(connections);  // 释放一个连接资源，connections加1
```

这种方法的优点:
- 简单而有效地限制了并发连接数
- 当达到最大连接数时，新的连接请求会自动阻塞，而不是被拒绝
- 当有连接关闭时，等待的连接请求会自动被处理

实际实现:
```c
// 初始化信号量
semaphore connections = N;
mutex = 1;

// 服务器主循环
while (true) {
    P(connections);  // 尝试获取连接资源
    
    // 接受新连接的代码
    socket = accept(server_socket, ...);
    
    // 创建新线程处理连接
    create_thread(handle_connection, socket);
}

// 连接处理函数
void handle_connection(socket) {
    // 处理客户端请求...
    
    // 连接完成，关闭套接字
    close(socket);
    
    // 释放连接资源
    V(connections);
}
```

这种设计确保了服务器在任何时候最多只有N个活动连接，有效防止了资源耗尽和潜在的拒绝服务攻击。

## 选择题

### 选择题1
**题干**: 若信号量S的初值为2，当前值为-1，则表示有_____等待进程。
A. 2个 
B. 1个
C. 0个 
D. 3个

**解析**: 信号量S的物理含义：当S>0时，表示系统中某类资源的可用数量；当S≤0时，|S|表示等待该资源的进程数。因此，当S=-1时，表示有|S|=|-1|=1个等待进程。

**答案**: B

**题干**: 在操作系统中，P、V操作是一种_____。
A. 机器指令 
B. 系统调用命令
C. 作业控制命令 
D. 低级进程通信原语

**解析**: P、V操作是基本的进程同步原语，用于解决进程间的同步与互斥问题，属于低级进程通信原语。它们不是机器指令（虽然实现可能依赖原子指令），也不是系统调用命令或作业控制命令。

**答案**: D

### 选择题2
**题干**: 下述哪个选项不是管程的组成部分_____。
A. 对局部于管程的数据结构设置初值的语句
B. 局部于管程的共享数据说明
C. 管程内对数据结构进行操作的一组过程
D. 管程外过程调用管程内数据结构的说明

**解析**: 管程的组成部分包括：局部于管程的共享数据结构、对共享数据结构进行操作的一组函数，以及对局部于管程的数据设置初始值的语句。而管程外过程调用管程内数据结构的说明不是管程自身的组成部分，属于管程的使用方式。

**答案**: D

**题干**: 临界区是_____。
A. 一段共享数据区 
B. 一段程序
C. 一个互斥资源 
D. 一个缓冲区

**解析**: 临界区是进程中访问临界资源的那段代码，即一段程序。临界资源是一段时间内仅允许一个进程使用的资源，而临界区则是对这些资源进行访问和操作的代码部分。

**答案**: B

### 选择题3
**题干**: 用P、V操作管理临界区时，信号量的初值应定义为_____。
A. 1 
B. 2
C. -1 
D. 0

**解析**: 当使用P、V操作管理临界区时，为了实现互斥访问，信号量的初值应设为1，表示初始时有一个资源可用，即允许一个进程进入临界区。一旦有进程进入临界区，它会执行P操作使信号量变为0，其他进程无法进入临界区；当它离开时，执行V操作使信号量恢复为1。

**答案**: A

**题干**: 对于两个并发进程，设互斥信号量为mutex,若mutex=0则_____。
A. 表示有一个进程进入临界区，另一个进程等待进入
B. 表示没有进程进入临界区
C. 表示有一个进程进入临界区
D. 表示有两个进程进入临界区

**解析**: 互斥信号量初值通常为1，当mutex=0时，表示有一个进程已经进入临界区，该进程执行了P(mutex)操作使信号量值从1变为0。此时如果另一个进程也想进入临界区，它会因执行P(mutex)操作而被阻塞，直到第一个进程执行V(mutex)操作离开临界区。

**答案**: C

### 选择题4
**题干**: 对信号量S执行V操作后，下述选项正确的是_____。
A. 当S小于0时唤醒一个阻塞进程
B. 当S小于等于0时唤醒一个阻塞进程
C. 当S小于0时唤醒一个就绪进程
D. 当S小于等于0时唤醒一个就绪进程

**解析**: 执行V(S)操作后，S的值增加1。如果此时S≤0，说明有进程因执行P(S)操作而被阻塞，此时系统会唤醒一个因等待该信号量而阻塞的进程，将其状态从阻塞改为就绪，放入就绪队列。该进程不是直接变为运行状态，而是先变为就绪状态。

**答案**: B

**题干**: 对信号量X执行P操作时，若 _____ 则进程进入等待状态。
A. X-1<0 
B. X-1<=0
C. X-1>0 
D. X-1>=0

**解析**: P操作的定义是：将信号量的值减1，然后检查是否小于0，如果小于0，则进程进入等待状态。因此，当X-1<0（即X<1）时，进程进入等待状态。

**答案**: A

### 选择题5
**题干**: 有若干并发进程均将共享变量count的值加1一次，那么有关count值说法正确的是_____。
A. 得到的结果肯定不正确
B. 得到的结果肯定正确
C. 若控制这些并发进程互斥执行count加1操作，count中的值正确
D. A，B，C均不对

**解析**: 当多个并发进程同时对共享变量count进行加1操作时，如果不加以控制，可能会出现竞争条件，导致结果不正确。例如，两个进程可能同时读取count的值，分别加1后写回，结果count只增加了1而不是2。如果控制这些进程互斥执行count加1操作（如使用P、V操作保护临界区），则count的最终值将是正确的。

**答案**: C

### 选择题6
**题干**: 下述关于管程的描述中错误的是____ 。
A. 管程是一种进程同步工具，解决了信号量机制中大量同步操作分散问题
B. 管程每次只允许一个进程进入管程
C. 管程中的signal操作的作用和信号量机制中的signal操作相同
D. 管程是被进程调用的

**解析**: 管程中的signal操作与信号量机制中的V(signal)操作不完全相同。在信号量机制中，V操作将信号量的值加1，如果有进程在该信号量上阻塞，则唤醒一个进程。而在管程中，signal操作用于唤醒在条件变量上等待的一个进程，且根据管程的实现方式，可能导致调用signal的进程暂时被阻塞，直到被唤醒的进程离开管程或等待另一个条件。

**答案**: C

## 填空题

### 填空题1
**题干**: 如果信号量的当前值为-4，则表示系统中在该信号量上有 _____ 个等待进程。

**答案**: 4

**题干**: 对于信号量可以做 ① 操作和 ② 操作， ③ 操作用于阻塞进程， ④ 操作用于释放进程。程序中的 ⑤ 操作应谨慎使用，以保证其使用的正确性，否则执行时可能发生死锁。

**答案**: ①P(wait) ②V(signal) ③P(wait) ④V(signal) ⑤P(wait)

**题干**: 信号量的物理意义是：当信号量值大于0时表示 ① ；当信号量值小于0时，其绝对值为 ② 。

**答案**: ①可用资源数量 ②等待该资源的进程数

### 填空题2
**题干**: 有m个进程共享同一临界资源，若使用信号量机制实现对临界资源的互斥访问，则信号量值的变化范围是 _____ 。

**答案**: 1到-(m-1)

**题干**: 访问临界资源的进程应该遵循的条件有： ① 、 ② 、 ③ 、和 ④ 。

**答案**: ①空闲让进 ②忙则等待 ③有限等待 ④让权等待

**题干**: 临界资源是指_____的资源。

**答案**: 一段时间内仅允许一个进程使用

**题干**: 管程由 ① 、 ② 和 ③ 三部分组成

**答案**: ①局部于管程的共享数据结构 ②对共享数据结构进行操作的一组函数 ③对局部于管程的数据设置初始值的语句

## 考研题

### 考研题-1 (09年)
**题干**: 三个进程P1、P2、P3互斥使用一个包含N(N>0)个单元的缓冲区，
P1每次用produce()生成一个正整数并用put()送入缓冲区某一空单元中；
P2每次用getodd()从该缓冲区中取出一个奇数并用countodd()统计奇数个数；
P3每次用geteven()从该缓冲区中取出一个偶数并用counteven()统计偶数个数。
请用信号量机制实现这三个进程的同步与互斥活动，并说明所定义的信号量含义。要求用伪代码编写。

**解析**:

需要定义的信号量:
- empty: 表示缓冲区中空闲单元的数量，初值为N
- odd: 表示缓冲区中奇数的数量，初值为0
- even: 表示缓冲区中偶数的数量，初值为0
- mutex: 用于保护缓冲区的互斥访问，初值为1

伪代码实现:
```
semaphore empty=N; // 空闲单元数量
semaphore odd=0, even=0; // 奇数和偶数的数量
semaphore mutex=1; // 互斥访问缓冲区

main()
cobegin
{ 
    Process P1()
    while(true)
    { 
        number=produce(); // 生成一个正整数
        P(empty); // 申请一个空闲单元
        P(mutex); // 互斥访问缓冲区
        put(); // 将数据放入缓冲区
        V(mutex); // 释放互斥访问
        
        // 根据奇偶性增加相应的信号量
        if (number % 2 == 0) 
            V(even); // 如果是偶数，增加even信号量
        else 
            V(odd); // 如果是奇数，增加odd信号量
    }

    Process P2()
    while(true)
    { 
        P(odd); // 等待奇数
        P(mutex); // 互斥访问缓冲区
        getodd(); // 取出一个奇数
        V(mutex); // 释放互斥访问
        V(empty); // 释放一个缓冲区单元
        countodd(); // 统计奇数
    }

    Process P3()
    while(true)
    { 
        P(even); // 等待偶数
        P(mutex); // 互斥访问缓冲区
        geteven(); // 取出一个偶数
        V(mutex); // 释放互斥访问
        V(empty); // 释放一个缓冲区单元
        counteven(); // 统计偶数
    }
} 
coend
```

这个解决方案确保了:
1. 互斥访问缓冲区（通过mutex信号量）
2. 生产者和消费者之间的同步（通过empty、odd和even信号量）
3. 奇数和偶数被正确分配给对应的消费者进程

### 考研题2 (09年)
**题干**: 单处理机系统中，可并行的是 。
Ⅰ. 进程与进程 Ⅱ. 处理机与设备
Ⅲ. 处理机与通道 Ⅳ. 设备与设备
A. Ⅰ、Ⅱ和Ⅲ 
B. Ⅰ、Ⅱ和Ⅳ
C. Ⅰ、Ⅲ和Ⅳ 
D. Ⅱ、Ⅲ和Ⅳ

**解析**: 在单处理机系统中，同一时刻只能有一个进程在处理机上运行，因此进程之间不能并行执行。处理机可以与外设（如磁盘、打印机等）并行工作，也可以与通道（I/O控制器）并行工作。外设之间也可以并行工作，例如，一个进程可以同时使用打印机和磁盘。因此，可并行的是选项Ⅱ、Ⅲ和Ⅳ。

**答案**: D

### 考研题2 (10年)
**题干**: 设与某资源相关联的信号量初值为3，当前值为1，若M表示该资源的可用个数，N表示等待该资源的进程数，则M、N分别是 。
A. 0，1 
B. 1，0
C. 1，2 
D. 2，0

**解析**: 信号量的物理含义是：当信号量值大于0时，表示系统中可用资源的数量；当信号量值小于0时，其绝对值表示等待该资源的进程数。当前信号量值为1>0，表示有1个资源可用，即M=1。由于信号量值大于0，表示没有进程等待该资源，即N=0。

**答案**: B

### 考研题3 (10年)
**题干**: 进程P0和P1的共享变量定义及初值为：
boolean flag[2]; int turn=0;
flag[0]=false;flag[1]=false;
进程P0和P1访问临界资源的类C代码实现如下：
```
void P0 //进程P0
{ while (TRUE)
  { flag[0]=TRUE;
    turn=1;
    while (flag[1] && turn==1);
    临界区;
    flag[0]=FALSE;
  }
}
void P1 //进程P1
{ while (TRUE)
  { flag[1]=TRUE;
    turn=0;
    while (flag[0] && turn==0);
    临界区;
    flag[1]=FALSE;
  }
}
```
则并发执行进程P0和P1时产生的情况是 。
A. 不能保证进程互斥进入临界区，会出现"饥饿"现象
B. 不能保证进程互斥进入临界区，不会出现"饥饿"现象
C. 能保证进程互斥进入临界区，会出现"饥饿"现象
D. 能保证进程互斥进入临界区，不会出现"饥饿"现象

**解析**: 这段代码实现了Peterson算法，它能保证互斥访问临界区。

互斥性分析：
- 假设P0和P1同时进入临界区，则必须有flag[0]=true, flag[1]=true
- 对于P0，必须有turn!=1或flag[1]=false才能进入临界区
- 对于P1，必须有turn!=0或flag[0]=false才能进入临界区
- 但当flag[0]=true, flag[1]=true时，turn只能是0或1，不可能同时满足两个条件
- 因此，P0和P1不可能同时进入临界区

无饥饿性分析：
- 如果P0想进入临界区，设置flag[0]=true和turn=1
- 如果P1不想进入临界区，则flag[1]=false，P0可以立即进入
- 如果P1也想进入并已设置flag[1]=true和turn=0，则P0会等待
- 当P1执行完临界区后，将设置flag[1]=false，使P0可以进入
- 反之亦然
- 因此，算法不会出现饥饿现象

**答案**: D

### 考研题4 (11年)
**题干**: 有两个并发执行的进程P1和P2，共享初值为1的变量x，P1对x加1，P2对x减1。加1和减1操作的指令序列分别如下所示。
```
//加1操作            //减1操作
load R1，x          Load R2，x
inc R1              dec R2
store x，R1         store x，R2
```
两个操作完成后，x的值____。
A. 可能为-1和3 
B. 只能为1
C. 可能为0、1或2 
D. 可能为-1、0、1或2

**解析**: 
两个进程P1和P2分别对x执行+1和-1操作，在并发执行时，由于这些操作不是原子的，可能出现交错执行的情况。

考虑以下可能的执行序列：
1. P1完全执行，然后P2完全执行：x变为1+1=2，再变为2-1=1
2. P2完全执行，然后P1完全执行：x变为1-1=0，再变为0+1=1
3. P1执行load R1,x；P2执行load R2,x（此时R1=R2=1）；P1执行inc R1（R1=2）；P2执行dec R2（R2=0）；P1执行store x,R1（x=2）；P2执行store x,R2（x=0）
4. 与3类似，但P2先执行store，结果x=2

因此，最终x的值可能为0、1或2，取决于指令的具体执行顺序。由于P1和P2都是从初值1开始操作，所以x的值不可能为-1或3。

**答案**: C

### 考研题5 (11年)
**题干**: 某银行提供一个服务窗口和10个供顾客等待的座位。顾客到达银行时，若有空座位，则到取号机上领取一个号，等待叫号。取号机每次仅允许一个顾客使用。当营业员空闲时，通过叫号选取一位顾客，并为其服务。顾客及营业员的活动描述如下：
```
cobegin
{ process 顾客
  { 从取号机获取一个号码；
    等待叫号；
    获得服务； }

  process 营业员
  { while（TRUE）
    { 叫号；
      为顾客服务；} }
}coend
```
请添加必要的信号量和P、V（或wait（）、signal（））操作，实现上述过程中的互斥与同步。要求写出完整的过程，说明信号量的含义并赋初值。

**解析**:

需要定义的信号量:
- mutex: 互斥使用取号机，初值为1
- empty: 表示空座位的数量，初值为10
- full: 表示已占座位的数量，初值为0
- service: 等待服务，初值为0

实现代码:
```
semaphore mutex=1; // 互斥使用取号机
semaphore empty=10; // 空座位的数量
semaphore full=0; // 已占座位的数量
semaphore service=0; // 等待叫号

cobegin
{ 
    process 顾客i
    { 
        P(empty);    // 检查是否有空座位
        P(mutex);    // 互斥使用取号机
        从取号机获得一个号;
        V(mutex);    // 释放取号机
        V(full);     // 已占座位数加1
        P(service);  // 等待叫号
        获得服务;
    }

    process 营业员
    { 
        while(TRUE)
        { 
            P(full);    // 检查是否有等待的顾客
            V(empty);   // 释放一个座位
            V(service); // 叫号
            为顾客服务;
        }
    }
}coend
```

解释:
1. 顾客到达时，首先检查是否有空座位(P(empty))
2. 如果有空座位，尝试互斥使用取号机(P(mutex))
3. 获取号码后，释放取号机(V(mutex))
4. 占用一个座位(V(full))，等待叫号(P(service))
5. 营业员检查是否有等待的顾客(P(full))
6. 叫号时，释放一个座位(V(empty))并通知顾客(V(service))
7. 为顾客提供服务

这个解决方案确保了:
1. 取号机的互斥使用
2. 座位资源的正确管理
3. 顾客和营业员之间的同步
