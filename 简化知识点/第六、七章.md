# 操作系统第六、七章：进程同步与同步实例

## 第六章：同步工具

### 1. 进程同步基础概念

#### 1.1 进程的相互制约

* **直接制约关系** ：合作进程之间产生的制约关系
* **间接制约关系** ：共享资源产生的制约关系

#### 1.2 竞争条件

* **定义** ：多个进程并发访问和操作同一数据，且执行结果与访问发生的特定顺序有关
* **解决方法** ：并发进程必须同步

#### 1.3 共享变量的问题

例如，两个进程同时执行 x 加 1 的操作：

```
A:              B:
R1 = x;         R2 = x;
R1 = R1 + 1;    R2 = R2 + 1;
x = R1;         x = R2;
```

* 如果顺序执行A后B，x值增加2
* 如果交错执行（R1=x; R2=x; R1=R1+1; x=R1; R2=R2+1; x=R2），则x值只增加1
* 这种错误称为"与时间有关的错误"，因为没有互斥使用共享变量

### 2. 临界区问题

#### 2.1 临界区定义

* **临界资源** ：一段时间内仅允许一个进程使用的资源
* **临界区/临界段** ：进程中访问临界资源的那段代码
* **同类临界区** ：所有与同一临界资源相关联的临界区

#### 2.2 临界区问题的通用结构

```
do {
    进入区 entry section      // 检查是否可进入临界区
    临界区 critical section   // 访问临界资源
    退出区 exit section       // 指示已经离开临界区
    剩余区 remainder section  // 执行其他代码
} while(true);
```

#### 2.3 临界区问题的解决条件

1. **互斥** ：如果进程Pi在其临界区内执行，那么其他进程不能在临界区内执行
2. **前进** ：如果没有进程在临界区内执行且有进程需要进入临界区，那么只有不在剩余区执行的进程可以参与决策，以确定下一个进入临界区的进程，且选择不能无限期延长
3. **有限等待** ：一个进程提出进入临界区请求后到该请求得到允许的这段时间内，其他进程进入临界区的次数必须有限

#### 2.4 访问临界资源应遵循的原则

1. **空闲让进** ：若无进程处于临界区时，应允许一个进程进入临界区
2. **忙则等待** ：当已有进程进入临界区，其他进程必须等待
3. **有限等待** ：应保证要求进入临界区的进程在有限时间内进入临界区
4. **让权等待** ：当进程不能进入自己的临界区时，应释放处理机

#### 2.5 同步与互斥

* **同步** ：多个相互合作的进程在关键点上需要互相等待或交换信息的相互制约关系
* **互斥** ：当一个进程使用某资源时，其他希望使用该资源的进程必须等待，直到该进程释放资源后才允许其他进程访问

### 3. Peterson 算法及其他软件解决方案

#### 3.1 算法1 - 轮转法

```
int turn = 0;  // 指示轮到哪个进程

// 进程P0
do {
    while (turn != 0);  // 等待轮到自己
    临界区代码CS0;
    turn = 1;  // 轮到P1
    其他代码;
} while (true);

// 进程P1
do {
    while (turn != 1);  // 等待轮到自己
    临界区代码CS1;
    turn = 0;  // 轮到P0
    其他代码;
} while (true);
```

问题：两个进程必须以交替次序进入临界区，不满足"空闲让进"原则

#### 3.2 算法2 - 标志法

```
boolean flag[2] = {false, false};  // 表示进程是否在临界区

// 进程P0
do {
    while (flag[1]);  // 检查P1是否在临界区
    flag[0] = true;   // 标记P0进入临界区
    临界区代码CS0;
    flag[0] = false;  // 标记P0离开临界区
    其他代码;
} while (true);

// 进程P1
do {
    while (flag[0]);  // 检查P0是否在临界区
    flag[1] = true;   // 标记P1进入临界区
    临界区代码CS1;
    flag[1] = false;  // 标记P1离开临界区
    其他代码;
} while (true);
```

问题：解决了空闲让进，但可能两个进程同时进入临界区（违背"忙则等待"）

#### 3.3 算法3 - 先标记后检查法

```
boolean flag[2] = {false, false};  // 表示进程是否想进入临界区

// 进程P0
do {
    flag[0] = true;   // 标记P0想进入临界区
    while (flag[1]);  // 检查P1是否也想进入
    临界区代码CS0;
    flag[0] = false;  // 标记P0不再想进入临界区
    其他代码;
} while (true);

// 进程P1
do {
    flag[1] = true;   // 标记P1想进入临界区
    while (flag[0]);  // 检查P0是否也想进入
    临界区代码CS1;
    flag[1] = false;  // 标记P1不再想进入临界区
    其他代码;
} while (true);
```

问题：可能导致两个进程都进不了临界区（互相谦让）

#### 3.4 算法4 - Peterson算法

```
boolean flag[2] = {false, false};  // 表示进程是否想进入临界区
int turn;  // 指示优先让哪个进程进入临界区

// 进程P0
do {
    flag[0] = true;   // 标记P0想进入临界区
    turn = 1;         // 优先让P1进入
    while (flag[1] && turn == 1);  // 若P1想进入且优先级给P1，则等待
    临界区代码CS0;
    flag[0] = false;  // 标记P0不再想进入临界区
    其他代码;
} while (true);

// 进程P1
do {
    flag[1] = true;   // 标记P1想进入临界区
    turn = 0;         // 优先让P0进入
    while (flag[0] && turn == 0);  // 若P0想进入且优先级给P0，则等待
    临界区代码CS1;
    flag[1] = false;  // 标记P1不再想进入临界区
    其他代码;
} while (true);
```

Peterson算法是正确的，可以保证互斥访问并避免死锁。

### 4. 同步的硬件解决方案

#### 4.1 禁止中断方法

```
关中断;
临界区;
开中断;
```

* **优点** ：简单直接
* **缺点** ：
* 限制了处理机交替执行程序的能力，降低执行效率
* 将关中断权力交给用户进程不安全，可能导致系统终止

#### 4.2 硬件指令方法

##### 4.2.1 Test-and-Set (TS) 指令

```
boolean TS(boolean *lock) {
    boolean old;
    old = *lock;      // 保存锁的原值
    *lock = true;     // 设置锁为占用状态
    return old;       // 返回锁的原值
}

// 使用TS实现互斥
do {
    while (TS(&lock));  // 若lock原值为true，则循环等待
    临界区代码;
    lock = false;      // 释放锁
    其他代码;
} while (true);
```

##### 4.2.2 Swap 指令

```
void Swap(boolean *a, boolean *b) {
    boolean temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

// 使用Swap实现互斥
do {
    key = true;
    while (key != false)   // 循环直到key变为false
        Swap(&lock, &key); // 交换lock和key的值
    临界区代码;
    lock = false;         // 释放锁
    其他代码;
} while (true);
```

#### 4.3 锁机制

* **锁变量** ：表示资源状态，0表示资源可用(开锁)，1表示资源已被占用(关锁)
* **上锁原语** ：

```
  lock(w) {    while (w == 1);  // 若已锁定则等待    w = 1;           // 加锁}
```

* **开锁原语** ：

```
  unlock(w) {    w = 0;  // 解锁}
```

#### 4.4 自旋锁

* 当一个进程试图获取锁但锁已被占用时，进程会持续检查锁的状态（自旋）直到锁可用
* **适用场景** ：中断处理程序（不允许睡眠）
* **最佳使用时间** ：持有锁的时间小于两次上下文切换的时间
* **读/写自旋锁** ：允许多个进程同时读，但写操作需要独占锁

### 5. 信号量 (Semaphores)

#### 5.1 信号量定义

* 由荷兰科学家Dijkstra提出
* 信号量S是一个整型变量，除初始化外只能通过两个标准原子操作wait()和signal()访问
  ```
  wait(S) {         // 原称为P操作    while (S <= 0)         do nothing;    S--;}signal(S) {       // 原称为V操作    S++;}
  ```

#### 5.2 信号量类型

* **计数信号量** ：值可以是任意非负整数，初始化为可用资源的数量
* **二进制信号量** ：值只能为0和1，又称互斥锁

#### 5.3 信号量实现

```
typedef struct {
    int value;
    struct process *list;  // 等待进程队列
} semaphore;

// wait操作
wait(semaphore *s) {
    s->value--;
    if (s->value < 0) {
        add this process to s->list;
        block();  // 挂起进程
    }
}

// signal操作
signal(semaphore *s) {
    s->value++;
    if (s->value <= 0) {
        remove a process P from s->list;
        wakeup(P);  // 唤醒进程
    }
}
```

#### 5.4 信号量的物理含义

* 当value > 0：表示系统中当前可用资源的数目
* 当value < 0：其绝对值表示系统中因请求该类资源而被阻塞的进程数目

#### 5.5 利用信号量实现互斥

```
semaphore mutex = 1;  // 初值为1

P1() {
    P1剩余区;
    wait(mutex);
    P1的临界区;
    signal(mutex);
    P1剩余区;
}

P2() {
    P2剩余区;
    wait(mutex);
    P2的临界区;
    signal(mutex);
    P2剩余区;
}
```

#### 5.6 利用信号量实现前趋关系

可以使用信号量来控制进程的执行顺序，保证某些进程必须在其他进程之后执行。

#### 5.7 死锁与饥饿

* **死锁** ：两个或多个进程无限等待一个事件，而该事件只能由等待进程引起
* **饥饿** ：进程无限期地被阻塞，永远无法从等待队列中移除

### 6. 信号量集机制

#### 6.1 AND型信号量

* **基本思想** ：将进程运行过程中需要的多类资源一次性全部分配，使用完后再一起释放
* **SP操作(Swait)** ：

```
  SP(S1, S2, ..., Sn) {    if (S1 >= 1 && S2 >= 1 && ... && Sn >= 1) {        for (i = 1; i <= n; i++)             Si = Si - 1;    } else {        将进程插入第一个小于1的信号量等待队列;        将调用进程的程序计数器置为SP的第一条指令;    }}
```

* **SV操作(Ssignal)** ：

```
  SV(S1, S2, ..., Sn) {    for (i = 1; i <= n; i++) {        Si = Si + 1;        唤醒Si等待队列上的所有进程;        并将它们插入就绪队列;    }}
```

#### 6.2 一般信号量集

* **基本思想** ：进程可以一次申请多类资源，每类资源可以申请多个
* **SP操作** ：

```
  SP(S1, t1, d1, S2, t2, d2, ..., Sn, tn, dn) {    // ti为下限值，di为资源申请量    if (S1 >= t1 && S1 >= d1 && ... && Sn >= tn && Sn >= dn) {        for (i = 1; i <= n; i++)             Si = Si - di;    } else {        将进程插入第一个资源数小于ti或di的信号量等待队列;        将调用进程的程序计数器设置为SP的第一条指令;    }}
```

* **SV操作** ：

```
  SV(S1, d1, S2, d2, ..., Sn, dn) {    for (i = 1; i <= n; i++) {        Si = Si + di;        唤醒队列Si上的所有进程;        并将它们插入就绪队列;    }}
```

### 7. 管程 (Monitors)

#### 7.1 管程定义

管程是由Hoare定义的一种高级同步机制，包含：

* 局部于管程的共享数据结构
* 对共享数据结构进行操作的一组函数
* 对局部于管程的数据设置初始值的语句

#### 7.2 管程语法

```
monitor monitor_name {
    // 共享变量声明
    variable declarations;
  
    // 对数据结构操作的函数
    procedure P1(...) { ... }
    procedure P2(...) { ... }
    ...
    procedure Pn(...) { ... }
  
    // 设初值语句
    {
        initialization code;
    }
}
```

#### 7.3 管程基本特性

1. 局部于管程的数据只能被管程内的函数访问
2. 进程只能通过调用管程内的函数访问共享数据
3. 每次仅允许一个进程在管程内执行函数
4. 管程的互斥访问由编译程序自动添加，不需程序员关心

#### 7.4 条件变量

* 用于进程等待和唤醒
* 支持两种操作：
  * **wait()** : 调用进程挂起，直到另一个进程调用signal
  * **signal()** : 唤醒一个在条件变量上挂起的进程

## 第七章：同步实例

### 1. 生产者-消费者问题 (有限缓冲问题)

#### 1.1 问题描述

* 一组生产者进程向一组消费者进程提供产品
* 它们共享一个有界缓冲池
* 缓冲池中每个缓冲区可存放一个产品
* 生产者不断生产产品并放入缓冲池，消费者不断从缓冲池取出产品并消费

#### 1.2 同步关系

* 当缓冲池满时生产者进程需等待
* 当缓冲池空时消费者进程需等待
* 诸进程应互斥使用缓冲池

#### 1.3 使用信号量解决

```
semaphore empty = n;    // 空缓冲区数量，初值为n
semaphore full = 0;     // 满缓冲区数量，初值为0
semaphore mutex = 1;    // 互斥访问缓冲区，初值为1

// 生产者进程
while (true) {
    生产一个产品;
    wait(empty);     // 等待空缓冲区
    wait(mutex);     // 等待互斥访问权
    将产品放入缓冲区;
    signal(mutex);   // 释放互斥访问权
    signal(full);    // 增加满缓冲区数量
}

// 消费者进程
while (true) {
    wait(full);      // 等待满缓冲区
    wait(mutex);     // 等待互斥访问权
    从缓冲区取出产品;
    signal(mutex);   // 释放互斥访问权
    signal(empty);   // 增加空缓冲区数量
    消费产品;
}
```

注意：wait操作的顺序不能颠倒，否则可能导致死锁。

#### 1.4 使用管程解决

管程PC可以包含以下元素：

* 共享变量：缓冲区数组buffer[n]，计数器count，指针nextin和nextout
* 条件变量：notfull和notempty
* 操作函数：append(添加产品)和take(取出产品)

### 2. 读者-写者问题

#### 2.1 问题描述

* 一个数据集可供多个并发进程共享
* 一些进程只读数据集(读者)，其他进程可能更新数据集(写者)
* 允许多个读进程同时读数据集
* 一个写进程不能与其他进程(读者或写者)同时访问数据集

#### 2.2 读者-写者问题分类

* **读者优先** ：当写者提出访问请求后，仍允许新读者进入
* **写者优先** ：当写者提出访问请求后，不允许新读者进入，且等待的写者可以跳过等待的读者进行写操作

#### 2.3 使用信号量解决(读者优先)

```
semaphore mutex = 1;      // 互斥访问readcount
semaphore writer = 1;     // 实现读写互斥和写写互斥
int readcount = 0;        // 记录当前正在读的进程数

// 读者进程
wait(mutex);
if (readcount == 0)      // 第一个读者需要获取writer信号量
    wait(writer);
readcount++;
signal(mutex);

读数据集;                 // 实际读取数据

wait(mutex);
readcount--;
if (readcount == 0)      // 最后一个读者释放writer信号量
    signal(writer);
signal(mutex);

// 写者进程
wait(writer);
写数据集;                 // 实际写入数据
signal(writer);
```

### 3. 哲学家进餐问题

#### 3.1 问题描述

* 五个哲学家围坐在一张圆桌前
* 桌上有五个碗和五支筷子，每两个哲学家之间放一支筷子
* 哲学家的生活方式是交替地思考和进餐
* 哲学家饥饿时需要同时拿起左右两支筷子才能进餐
* 进餐完毕，放下筷子继续思考

#### 3.2 使用信号量解决

```
semaphore stick[5] = {1, 1, 1, 1, 1};  // 每支筷子的信号量，初值均为1

// 哲学家i的活动
while (true) {
    wait(stick[i]);               // 拿起左边筷子
    wait(stick[(i+1) % 5]);       // 拿起右边筷子
    进餐;
    signal(stick[i]);             // 放下左边筷子
    signal(stick[(i+1) % 5]);     // 放下右边筷子
    思考;
}
```

这种解法可能导致死锁。解决方法有：

1. 最多允许四个哲学家同时进餐
2. 仅当左右两支筷子均可用时，才允许拿起筷子进餐
3. 奇数号哲学家先拿左筷子再拿右筷子，偶数号哲学家相反

#### 3.3 使用管程解决

管程DP可以包含以下元素：

* 每个哲学家的状态数组state[5]，可能的状态有thinking, hungry, eating
* 每个哲学家的条件变量self[5]
* 操作函数：pickup(拿筷子)，putdown(放筷子)和test(测试是否可以进餐)

## 额外知识点

### Linux自旋锁（ARM版本）

* 锁本身是个32位整数，高16位表示叫号，低16位表示当前服务号
* 上锁过程：
  1. 锁内存总线执行
  2. 锁变量读入临时变量lockval
  3. lockval高16位加1后写回锁变量
  4. 如果失败再回去试一次
  5. 循环检查高16位是否等于低16位
* 解锁过程：锁变量低16位加1

这种方式的自旋锁使用"票号"机制，确保公平性（先来先服务）。

### 各种同步问题的核心区别

1. **互斥问题** ：确保同一时刻只有一个进程可以访问共享资源。
2. **同步问题** ：确保进程按照特定顺序执行。
3. **生产者-消费者问题** ：核心是缓冲区管理和访问同步。
4. **读者-写者问题** ：允许并发读，但写操作需要独占访问。
5. **哲学家进餐问题** ：资源分配中避免死锁和饥饿。

### 注意事项

1. 在使用信号量时，wait和signal操作的顺序非常重要，顺序错误可能导致死锁。
2. 有些同步问题需要多个信号量协同工作，理解各信号量的作用至关重要。
3. 与同步相关的错误（如死锁、饥饿、优先级反转）通常难以调试，因为它们往往与特定的时序相关。
4. 管程比信号量提供了更高级的抽象，使代码更易于理解和维护，但可能效率略低。
