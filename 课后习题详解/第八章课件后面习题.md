# 第8章 死锁课后习题

## 练习8.3
**题干**: Consider the following snapshot of a system:

| | Allocation | | | | Max | | | | Available | | | |
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| | A | B | C | D | A | B | C | D | A | B | C | D |
| T0 | 0 | 0 | 1 | 2 | 0 | 0 | 1 | 2 | 1 | 5 | 2 | 0 |
| T1 | 1 | 0 | 0 | 0 | 1 | 7 | 5 | 0 | | | | |
| T2 | 1 | 3 | 5 | 4 | 2 | 3 | 5 | 6 | | | | |
| T3 | 0 | 6 | 3 | 2 | 0 | 6 | 5 | 2 | | | | |
| T4 | 0 | 0 | 1 | 4 | 0 | 6 | 5 | 6 | | | | |

Answer the following questions using the banker's algorithm:

a. What is the content of the matrix Need?

b. Is the system in a safe state?

c. If a request from thread T1 arrives for (0,4,2,0), can the request be granted immediately?

（使用银行家算法回答以下问题：
a. Need矩阵的内容是什么？
b. 系统是否处于安全状态？
c. 如果线程T1请求资源(0,4,2,0)，能否立即满足该请求？）

**解析**:

### a. Need矩阵的内容

Need矩阵计算公式：Need[i,j] = Max[i,j] - Allocation[i,j]

计算结果如下：

| | Need | | | |
|---|---|---|---|---|
| | A | B | C | D |
| T0 | 0 | 0 | 0 | 0 |
| T1 | 0 | 7 | 5 | 0 |
| T2 | 1 | 0 | 0 | 2 |
| T3 | 0 | 0 | 2 | 0 |
| T4 | 0 | 6 | 4 | 2 |

### b. 系统安全状态分析

1. 初始状态:
   - Work = Available = (1,5,2,0)
   - Finish = (false,false,false,false,false)

2. 查找满足条件的进程:
   - T0: Need(0,0,0,0) ≤ Work(1,5,2,0)，可以分配
   - 更新: Work = (1,5,2,0) + (0,0,1,2) = (1,5,3,2), Finish[T0] = true

3. 继续查找:
   - T3: Need(0,0,2,0) ≤ Work(1,5,3,2)，可以分配
   - 更新: Work = (1,5,3,2) + (0,6,3,2) = (1,11,6,4), Finish[T3] = true

4. 继续查找:
   - T1: Need(0,7,5,0) ≤ Work(1,11,6,4)，可以分配
   - 更新: Work = (1,11,6,4) + (1,0,0,0) = (2,11,6,4), Finish[T1] = true

5. 继续查找:
   - T2: Need(1,0,0,2) ≤ Work(2,11,6,4)，可以分配
   - 更新: Work = (2,11,6,4) + (1,3,5,4) = (3,14,11,8), Finish[T2] = true

6. 继续查找:
   - T4: Need(0,6,4,2) ≤ Work(3,14,11,8)，可以分配
   - 更新: Finish[T4] = true

所有进程的Finish值都为true，存在安全序列<T0,T3,T1,T2,T4>，因此系统处于安全状态。

### c. T1请求资源(0,4,2,0)分析

1. 检查请求是否满足条件:
   - Request(0,4,2,0) ≤ Need[T1](0,7,5,0)? 是
   - Request(0,4,2,0) ≤ Available(1,5,2,0)? 是

2. 尝试分配:
   - Available' = (1,5,2,0) - (0,4,2,0) = (1,1,0,0)
   - Allocation[T1]' = (1,0,0,0) + (0,4,2,0) = (1,4,2,0)
   - Need[T1]' = (0,7,5,0) - (0,4,2,0) = (0,3,3,0)

3. 安全性检查:
   - Work = (1,1,0,0)
   - Finish = (false,false,false,false,false)
   
   分析发现没有进程的Need小于等于Work，无法找到安全序列。

因此，不能立即满足T1的请求(0,4,2,0)，因为这会导致系统进入不安全状态。

## 练习8.18
**题干**: Which of the six resource-allocation graphs shown in Figure 8.12 illustrate deadlock? For those situations that are deadlocked, provide the cycle of threads and resources. Where there is not a deadlock situation, illustrate the order in which the threads may complete execution.

（图8.12中的六个资源分配图中，哪些图说明了死锁？对于死锁情况，提供线程和资源的循环。对于没有死锁的情况，说明线程可能完成执行的顺序。）

注：由于无法看到原题中的图8.12，我将基于死锁检测的一般方法进行解析。

**解析**:

在资源分配图中检测死锁的方法：
1. 分析资源分配图中是否存在环路
2. 如果存在环路，检查是否每种资源类型只有一个实例：
   - 如果是，则存在死锁
   - 如果不是，则需要进一步分析是否所有环上的资源都被完全分配

对于没有提供具体图的情况，我们可以给出一些通用的死锁情况分析：

案例1：线程T1持有资源R1并请求R2，线程T2持有资源R2并请求R1
- 此时存在环路：T1→R2→T2→R1→T1
- 如果R1和R2各只有一个实例，则存在死锁

案例2：线程T1、T2、T3分别持有资源R1、R2、R3，并分别请求R2、R3、R1
- 此时存在环路：T1→R2→T2→R3→T3→R1→T1
- 如果这些资源各只有一个实例，则存在死锁

对于非死锁情况的例子：
1. 资源分配图中没有环路
2. 有环路但有足够的资源实例可以打破环路
3. 有些线程不在环路中并可以完成执行，释放资源后可能打破环路

线程可能完成执行的顺序通常由以下步骤确定：
1. 找出不阻塞的线程（即已获得所需全部资源或无需更多资源的线程）
2. 假设这些线程完成执行并释放资源
3. 检查是否有新的线程变为不阻塞
4. 重复步骤2和3直到所有线程完成或无法继续（死锁）

## 选择题

### 选择题1
**题干**: 要防止死锁的发生，可以通过破坏这四个必要条件之一来实现，但破坏 _____ 条件是不太实际的。
A. 循环等待 
B. 部分分配
C. 不可抢占 
D. 互斥

**解析**: 死锁产生的四个必要条件是：互斥条件、占有并等待条件（也称部分分配条件）、不可抢占条件和循环等待条件。其中，互斥条件是指一段时间内某资源仅为一个进程所占有。由于很多资源本身就是不可共享的（如打印机），因此破坏互斥条件通常是不太实际的。而其他三个条件都有可能通过系统设计来破坏。

**答案**: D

**题干**: 为多道程序提供的可共享资源不足时，可能出现死锁。但是，不适当的 _____ 也可能产生死锁。
A. 分配队列优先权 
B. 进程推进顺序
C. 资源的线性分配 
D. 进程优先权

**解析**: 除了资源不足外，进程推进顺序不当也是导致死锁的一个重要原因。例如，两个进程分别需要资源A和B，如果进程1先获取资源A再请求资源B，而进程2先获取资源B再请求资源A，就可能导致死锁。合理的资源请求顺序（如按资源类型的固定顺序申请）可以避免这种死锁。

**答案**: B

### 选择题2
**题干**: 采用资源剥夺法可以解除死锁，还可以采用 _____ 方法解除死锁。
A. 拒绝分配新资源 
B. 修改信号量
C. 执行并行操作 
D. 撤消进程

**解析**: 死锁解除的方法主要有两类：资源剥夺法和撤销进程法。资源剥夺法是指从一个或多个进程中抢占资源，分配给死锁进程，直到死锁解除。撤销进程法是指终止一个或多个死锁进程，释放它们占用的资源，打破死锁环路。拒绝分配新资源是死锁避免的策略，不是解除死锁的方法；修改信号量和执行并行操作也不是常规的死锁解除方法。

**答案**: D

**题干**: 在 _____ 的情况下，系统出现死锁。
A. 计算机系统发生了重大故障
B. 有多个封锁的进程同时存在
C. 若干进程因竞争资源而无休止地相互等待他方释放已占有的资源
D. 资源数大大小于进程数或进程同时申请的资源数大大超过资源总数

**解析**: 死锁的定义是：若干进程因竞争资源而无休止地相互等待对方释放已占有的资源的现象。选项A描述的是系统故障，不一定会导致死锁；选项B中"封锁的进程"可能只是临时被阻塞，不一定形成互相等待的环路；选项D中资源不足只是可能导致死锁的一个条件，不是死锁的充分条件。

**答案**: C

### 选择题3
**题干**: 银行家算法在解决死锁问题中是用于 _____ 的。
A. 检测死锁 
B. 预防死锁
C. 避免死锁 
D. 解除死锁

**解析**: 银行家算法是一种经典的死锁避免算法，它通过事先分析资源分配的安全性，在资源分配之前判断该分配是否会导致系统进入不安全状态，如果会，则拒绝分配。这种方法不像死锁预防那样对资源使用施加严格限制，也不像死锁检测那样允许死锁发生后再解决，而是在资源动态分配过程中避免系统进入不安全状态。

**答案**: C

**题干**: 资源的有序分配策略可以破坏 _____ 条件。
A. 占有且等待资源 
B. 循环等待资源
C. 非抢夺资源 
D. 互斥使用资源

**解析**: 资源的有序分配策略要求将系统中的所有资源按类型排序，并规定进程必须按照资源序号递增的顺序请求资源。这种方法可以破坏循环等待条件，因为如果所有进程都按照相同的顺序请求资源，就不可能形成循环等待。占有且等待条件的破坏需要一次性申请所有资源；非抢占条件的破坏需要允许资源被强制剥夺；互斥条件通常难以破坏。

**答案**: B

### 选择题4
**题干**: 某系统中有3个并发进程，都需要同类资源4个，试问该系统不会发生死锁的最少资源数是 _____ 。
A. 9 
B. 10
C. 11 
D. 12

**解析**: 根据死锁定理，当系统中的资源数大于或等于所有进程的最大需求之和减去最小者时，系统不会发生死锁。在这个例子中：
- 3个进程，每个进程最多需要4个资源
- 所有进程的最大需求之和：3×4=12
- 最小者（即单个进程的最大需求）：4
- 不会发生死锁的最少资源数：12-4+1=9

因此，系统中至少需要9个资源才能保证不会发生死锁。

**答案**: A

**题干**: 有序资源分配方法属于_____ 方法。
A. 死锁预防 
B. 死锁避免
C. 死锁检测 
D. 死锁解除

**解析**: 有序资源分配方法通过破坏死锁产生的必要条件之一（循环等待条件）来预防死锁，要求进程按照预定义的资源类型顺序申请资源。这种方法属于死锁预防，而不是死锁避免（如银行家算法）、死锁检测或死锁解除。

**答案**: A

### 选择题5
**题干**: 不能防止死锁的资源分配策略是_____。
A. 剥夺式分配方式 
B. 按序分配方式
C. 静态分配方式 
D. 互斥使用分配方式

**解析**: 防止死锁的资源分配策略包括：
- 剥夺式分配方式：破坏不可抢占条件
- 按序分配方式：破坏循环等待条件
- 静态分配方式：破坏占有并等待条件

而互斥使用是死锁产生的必要条件之一，单独的互斥使用分配方式不能防止死锁，反而可能导致死锁的发生。

**答案**: D

**题干**: 某计算机系统中有6台打印机，多个进程均最多需要2台打印机，规定每个进程一次仅允许申请一台打印机。为保证一定不发生死锁，则允许参与打印机资源竞争的最大进程数是__。
A. 3 
B. 4 
C. 5 
D. 6

**解析**: 根据死锁的必要条件，当系统中的资源数小于等于参与竞争的进程数时，且每个进程都占有一个资源并请求另一个资源时，就可能发生死锁。

在这个例子中：
- 总资源数：6台打印机
- 每个进程最多需要2台打印机，且一次只能申请1台

为避免死锁，需要确保即使每个进程都占有1台打印机后，还有至少1台打印机可用。因此，最大进程数应为6-1=5个。如果有6个进程，每个都占有1台打印机，就没有可用资源了，可能导致死锁。

**答案**: C

## 填空题

**题干**: 在有m个进程的系统中出现死锁时，死锁进程的个数k应该满足的条件是_____ 。

**答案**: 2 ≤ k ≤ m

**题干**: 银行家算法中，当一个进程提出的资源请求将导致系统从 ① 进入 ② 时，系统就拒绝它的资源请求。

**答案**: ①安全状态 ②不安全状态

**题干**: 对待死锁，一般应考虑死锁的预防、避免、检测和解除四个问题。典型的银行家算法是属于 ① ，破坏环路等待条件是属于 ② ，而剥夺资源是 ③ 的基本方法。

**答案**: ①死锁避免 ②死锁预防 ③死锁解除

## 考研题

### 考研题1 (09年)
**题干**: 某计算机中有8台打印机，由K个进程竞争使用，每个进程最多需要3台打印机。该系统可能会发生死锁的K的最小值为（）。
A. 2 
B. 3 
C. 4 
D. 5

**解析**: 根据死锁的必要条件和资源分配情况，当系统中进程数大于资源数时，如果每个进程都至少持有一个资源并请求更多资源，就有可能发生死锁。

在本题中：
- 总资源数：8台打印机
- 每个进程最多需要3台打印机

假设K=4，每个进程已占有2台打印机（共8台，刚好用完），但每个进程还需要1台打印机才能完成任务。此时，所有进程都在等待其他进程释放资源，形成了死锁。这是K=4时可能出现的死锁情况。

如果K=3，即使每个进程都占有2台打印机（共6台），系统中还有2台可用，足够满足任一进程的额外需求，因此不会发生死锁。

所以，K的最小值为4。

**答案**: C

### 考研题2 (11年)
**题干**: 某时刻进程的资源使用情况如下表所示：

| 进程 | 已分配资源 | | | 尚需资源 | | | 可用资源 | | |
|------|------------|--|--|----------|--|--|----------|--|--|
|      | R1 | R2 | R3 | R1 | R2 | R3 | R1 | R2 | R3 |
| P1   | 2  | 0  | 0  | 0  | 0  | 1  | 0  | 2  | 1  |
| P2   | 1  | 2  | 0  | 1  | 3  | 2  |    |    |    |
| P3   | 0  | 1  | 1  | 1  | 3  | 1  |    |    |    |
| P4   | 0  | 0  | 1  | 2  | 0  | 0  |    |    |    |

此时的安全序列是___。
A. P1，P2，P3，P4 
B. P1，P3，P2，P4
C. P1，P4，P3，P2 
D. 不存在

**解析**: 
使用银行家算法进行安全性检查：

1. 初始状态:
   - Work = Available = (0,2,1)
   - Finish = (false,false,false,false)

2. 查找满足条件的进程:
   - P1: Need(0,0,1) ≤ Work(0,2,1)，可以分配
   - 更新: Work = (0,2,1) + (2,0,0) = (2,2,1), Finish[P1] = true

3. 继续查找:
   - P4: Need(2,0,0) ≤ Work(2,2,1)，可以分配
   - 更新: Work = (2,2,1) + (0,0,1) = (2,2,2), Finish[P4] = true

4. 继续查找:
   - P3: Need(1,3,1) ≤ Work(2,2,2)，可以分配
   - 更新: Work = (2,2,2) + (0,1,1) = (2,3,3), Finish[P3] = true

5. 继续查找:
   - P2: Need(1,3,2) ≤ Work(2,3,3)，可以分配
   - 更新: Finish[P2] = true

所有进程的Finish值都为true，存在安全序列<P1,P4,P3,P2>。

**答案**: C

### 考研题3 (12年)
**题干**: 假设5个进程P0，P1，P2，P3，P4共享三类资源R1、R2、R3，这些资源总数分别为18，6，22。T0时刻的资源分配情况如下表所示，此时存在一个安全序列是：

| | 已分配 | | | 最大需求 | | |
|---|---|---|---|---|---|---|
| | R1 | R2 | R3 | R1 | R2 | R3 |
| P0 | 3 | 2 | 3 | 5 | 5 | 10 |
| P1 | 4 | 0 | 3 | 5 | 3 | 6 |
| P2 | 4 | 0 | 5 | 4 | 0 | 11 |
| P3 | 2 | 0 | 4 | 4 | 2 | 5 |
| P4 | 3 | 1 | 4 | 4 | 2 | 4 |

A. P0,P2,P4,P1,P3
B. P1,P0,P3,P4,P2
C. P2,P1,P0,P3,P4
D. P3,P4,P2,P1,P0

**解析**:
首先计算Need矩阵和Available向量：

Need矩阵：
| | R1 | R2 | R3 |
|---|---|---|---|
| P0 | 2 | 3 | 7 |
| P1 | 1 | 3 | 3 |
| P2 | 0 | 0 | 6 |
| P3 | 2 | 2 | 1 |
| P4 | 1 | 1 | 0 |

总资源：R1=18, R2=6, R3=22
已分配资源总和：R1=16, R2=3, R3=19
Available = 总资源 - 已分配 = (2,3,3)

使用银行家算法进行安全性检查：

1. 初始状态:
   - Work = Available = (2,3,3)
   - Finish = (false,false,false,false,false)

2. 查找满足条件的进程:
   - P1: Need(1,3,3) ≤ Work(2,3,3)，可以分配
   - 更新: Work = (2,3,3) + (4,0,3) = (6,3,6), Finish[P1] = true

3. 继续查找:
   - P2: Need(0,0,6) ≤ Work(6,3,6)，可以分配
   - 更新: Work = (6,3,6) + (4,0,5) = (10,3,11), Finish[P2] = true

4. 继续查找:
   - P0: Need(2,3,7) ≤ Work(10,3,11)，可以分配
   - 更新: Work = (10,3,11) + (3,2,3) = (13,5,14), Finish[P0] = true

5. 继续查找:
   - P3: Need(2,2,1) ≤ Work(13,5,14)，可以分配
   - 更新: Work = (13,5,14) + (2,0,4) = (15,5,18), Finish[P3] = true

6. 继续查找:
   - P4: Need(1,1,0) ≤ Work(15,5,18)，可以分配
   - 更新: Finish[P4] = true

所有进程的Finish值都为true，存在安全序列<P1,P2,P0,P3,P4>，该序列对应选项B。

**答案**: B
